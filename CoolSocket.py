import socket
from termcolor import colored
from time import sleep

# Надстройка над сокетом
# Умеет получать текст до определённого символа
# Можно задать стандартный символ до которого будет смотреть
# Возвращает подчищенную строку: удаляет последнюю линию, приводит к типу string

# Умеет отправлять текст
# Переход на новую строку и преобразование в байты уже учтены


class CoolSocket:

    # имя чисто для отладки в консоли
    name = colored("[Cool socket]", "cyan") + "  "
    
    # таймаут ожидания. Если таймаут истечёт, продолжит читать
    timeout = 2
    
    # стандартный символ до которого будет читать при приёме, чтобы каждый раз его не прописывать
    default_symbol = '>'
    
    # если хочешь чтобы весь контент который приходит тут же отображался в консоли ставишь True 
    autoPrinter = False
    
    # на случай если хочется пару секунд почитать при приёме что вообще происходит
    sleepTime = 0

    def __init__(self, ip, port):
        print(self.name + "Cool socket makes brrrrr")
        self.sock = socket.socket()
        self.sock.connect((ip, port))
        self.sock.settimeout(self.timeout)


# stopTime: для выхода по времени
    def GetContent(self, symbol=default_symbol, stopTime=False):
        print(self.name + "Get content")
        data = ""
        newData = ""

        if stopTime:
            self.sock.settimeout(2)

        while(symbol not in newData):
            try:
                newData = self.sock.recv(1024).decode()
            except Exception:
                if stopTime:
                    break
                print(self.name + "Getting content is slow :(")

            data += newData

        if stopTime:
            self.sock.settimeout(self.timeout)

        data = data.split('\n')
        data.pop()
        dataPretty = "\n".join(data)

        if self.autoPrinter:
            print(dataPretty)

        sleep(self.sleepTime)

        return dataPretty

    def SendContent(self, content):
        print(self.name + "Send \"" + content + "\"")
        content_bin = (content+"\n").encode()
        self.sock.send(content_bin)

    def SendGetContent(self, content, symbol=default_symbol):
        self.SendContent(content)
        return self.GetContent(symbol)

